# Medicare Plan Comparison Platform

## Overview

This is a full-stack web application for comparing Medicare Advantage plans with personalized match scoring. The platform helps users evaluate healthcare plans by displaying key metrics like premiums, deductibles, pharmacy coverage, and doctor networks. The system uses an animated circular progress indicator to show match scores and provides plan comparison tools with impact analysis.

**Core Purpose**: Enable Medicare beneficiaries to compare plans side-by-side, understand switching costs/benefits, and make informed healthcare decisions through visual data representation and personalized scoring.

## User Preferences

Preferred communication style: Simple, everyday language.

## System Architecture

### Frontend Architecture

**Framework**: React 18 with TypeScript using Vite as the build tool

**UI Component Library**: Shadcn/ui (Radix UI primitives) with Tailwind CSS for styling
- Component system follows the "New York" style variant
- Comprehensive component library including dialogs, cards, forms, navigation
- Custom healthcare-specific components (CircularProgress, MedicarePlanCard, PlanChangeImpact)

**Design System**:
- Healthcare portal aesthetic inspired by Oscar Health and UnitedHealthcare
- Professional, trustworthy interface with emphasis on data visualization
- Color-coded scoring system (green for 90-100%, amber for 75-89%, coral for <75%)
- Consistent spacing using Tailwind units (2, 3, 4, 6, 8)
- Animated circular progress indicators with 1.4s easing transitions

**State Management**:
- TanStack Query (React Query) for server state and API data fetching
- Local component state with React hooks
- No global state management library (Redux, Zustand, etc.)

**Routing**: Wouter for lightweight client-side routing
- Routes: Home (`/`), Compare Page (`/compare`), 404 fallback

**Key UI Patterns**:
- Card-based plan display with match scores in top-right corner
- Comparison footer that sticks to bottom when plans are selected
- Modal dialogs for forms (match score questionnaire, PDF summary generation)
- Plan change impact visualization showing savings/costs and network changes

### Backend Architecture

**Runtime**: Node.js with Express.js server

**Architecture Pattern**: Monolithic full-stack application with separate client/server directories
- `/client` - Frontend React application
- `/server` - Backend Express API and routing
- `/shared` - Shared TypeScript types and schemas

**API Structure**:
- RESTful endpoints prefixed with `/api`
- Routes registered in `server/routes.ts`
- Request logging middleware with duration tracking
- JSON body parsing with raw body preservation for webhook verification

**Development Setup**:
- Vite dev server in middleware mode for HMR during development
- Production build outputs to `dist/` directory
- TypeScript compilation with strict mode enabled

### Data Storage Solutions

**Database**: PostgreSQL via Neon serverless driver (`@neondatabase/serverless`)

**ORM**: Drizzle ORM with Drizzle-Kit for migrations
- Schema defined in `shared/schema.ts`
- Migration files in `/migrations` directory
- Push-based schema updates (`npm run db:push`)

**Schema Design**:

1. **Users Table**:
   - UUID primary key (generated by database)
   - Username/password authentication fields
   - Current plan tracking via `currentPlanId`

2. **Medicare Plans Table**:
   - Comprehensive plan details (carrier, year, star rating)
   - Financial metrics (premium, deductibles, out-of-pocket max)
   - Network information (pharmacies covered, doctor names)
   - Match scoring system (matchScore, recommended flag)
   - Decimal precision for currency values

3. **Plan Change Impact** (Interface only - not persisted):
   - Calculated comparison metrics between plans
   - Savings/cost analysis, network changes, coverage differences

**Storage Abstraction**:
- `IStorage` interface for CRUD operations
- In-memory implementation (`MemStorage`) for development/testing
- Designed for easy swapping to database-backed storage

### Authentication and Authorization

**Current State**: Basic authentication infrastructure in place
- User schema with username/password fields
- No active auth implementation in routes yet
- Session management prepared via `connect-pg-simple` for PostgreSQL-backed sessions

**Design**: Intended for session-based authentication (not JWT-based on dependencies)

### External Dependencies

**Third-Party Services** (Prepared but not actively integrated):
- Neon Database: Serverless PostgreSQL hosting
- Potential Medicare data APIs (not yet implemented)

**Development Tools**:
- Replit-specific plugins: cartographer, dev-banner, runtime-error-modal
- ESBuild for production server bundling
- TSX for TypeScript execution in development

**Key Libraries**:
- `@hookform/resolvers` + `react-hook-form` for form validation
- `date-fns` for date formatting
- `zod` for runtime schema validation
- `nanoid` for ID generation
- `cmdk` for command palette UI patterns

**Design Assets**:
- Custom fonts: DM Sans, Fira Code, Geist Mono, Architects Daughter
- Healthcare-optimized typography system
- System font fallbacks for reliability

### Build and Deployment

**Build Process**:
1. Frontend: Vite builds React app to `dist/public`
2. Backend: ESBuild bundles Express server to `dist/index.js`
3. Outputs are ESM modules (type: "module" in package.json)

**Scripts**:
- `dev`: Development server with HMR
- `build`: Production build for both client and server
- `start`: Run production server
- `db:push`: Apply schema changes to database

**Environment Requirements**:
- `DATABASE_URL` for PostgreSQL connection (enforced in drizzle.config.ts)
- Node environment detection via `NODE_ENV`